<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#">
	<head>
		<title>Implementer's Guide to SOCKS - Cookie Engineer's Web Log</title>

		<!-- Meta -->
		<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=0.5, maximum-scale=2, user-scalable=yes">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="creator" content="Cookie Engineer">
		<meta name="description" content="Implementer's Guide to SOCKS">
		<meta name="keywords" content="networking, nodejs, socks">
		<meta name="generator" content="Beer and VIM night coding sessions">
		<meta name="robots" content="index, follow">
		<link rel="alternate" type="application/rss+xml" href="../feed.xml">

		<!-- Social Meta -->
		<meta name="og:image" itemprop="image" content="https://cookie.engineer/design/about/avatar/cookiengineer.png">
		<meta name="og:title" content="Implementer's Guide to SOCKS - Cookie Engineer's Web Log">
		<meta name="og:description" content="A How-To Guide on building a SOCKS version 4/5 client and server from scratch, explaining related RFCs and potential quirks and problems with other implementations.">
		<meta name="og:site_name" content="Cookie Engineer's Web Log">
		<meta name="og:type" content="article">
		<meta name="twitter:card" content="summary">
		<meta name="twitter:domain" content="cookie.engineer">
		<meta name="twitter:title" property="og:title" itemprop="name" content="Implementer's Guide to SOCKS - Cookie Engineer's Web Log">
		<meta name="twitter:description" property="og:description" itemprop="description" content="A How-To Guide on building a SOCKS version 4/5 client and server from scratch, explaining related RFCs and potential quirks and problems with other implementations.">

		<!-- Website Design -->
		<link rel="stylesheet" href="/design/layout/index.css">
		<link rel="stylesheet" href="/weblog/design/index.css">

		<!-- Weblog Design -->
		<link rel="stylesheet" href="/weblog/design/layout/article.css">
		<script src="/weblog/design/layout/highlight.js"></script>
		<script src="/weblog/design/layout/article.js" defer></script>

		<!-- Website Functionality -->
		<link rel="stylesheet" href="/design/menu/index.css">
		<script src="/design/menu/index.js" defer></script>

		<!-- Magic: Copy/Paste -->
		<link rel="stylesheet" href="/design/magic/index.css">
		<script src="/design/magic/index.js" defer></script>

	</head>
	<body>
		<header>
			<aside id="menu" class="visible">
				<a id="menu-button" href="#menu">Menu</a>
				<a class="icon-section" href="/weblog/index.html">Web Log</a>
				<a class="icon-section" href="/index.html">Portfolio</a>
			</aside>
		</header>
		<section class="article">
			<h1>Implementer's Guide to SOCKS</h1>
			<article>
<section>
<p>
	Yesterday I was verifying that the SOCKS test suite of 
	 <a class="icon-github" href="https://github.com/tholian-network/stealth">Tholian Stealth</a> 
	is working and I realized that writing failsafe tests are not
	as easy as someone might think. So here's my write-up about
	the SOCKS protocol.
</p>
<p>
	The problem with SOCKS in a nutshell is that it is not as well
	documented as someone might think.
</p>
<p>
	Most people are even unaware of the role that a SOCKS proxy plays in
	between network connections and therefore don't know what exactly a
	SOCKS proxy can or cannot do in regards to blocking ads and malicious
	domains.
</p>
<p>
	So I thought that a reference-class article for SOCKS4 and SOCKS5
	would be nice, documenting its quirks and common pitfalls while
	implementing those protocols.
</p>
<p>
	For the implementation we're going to build in this article,
	we only need plain node.js and its 
	 <code>net</code>
	 core stack. The
	implementation will be peer-to-peer, which means it can be used
	for both the client-side and server-side whereas both sides are
	implemented in node.js for the sake of simplicity.
</p>
</section>

<section>
<h2>Introduction</h2>
<p>
	First off, you have to know that the 
	 <code>SOCKS</code>
	 protocol is specified as
	 <a class="icon-website" href="https://tools.ietf.org/html/rfc1928">RFC1928</a> 
	 and
	 <a class="icon-website" href="https://tools.ietf.org/html/rfc1929">RFC1929</a> 
	 and didn't change since
	 <code>1996</code>
	 so it's somewhat safe to assume that this is the final version
	of the network protocol.
</p>
<p>
	The SOCKS protocol in general and its role is pretty much what telephone
	operators did in the past. A client connects to the SOCKS proxy and
	requests to connect to a specific target. The proxy tries to connect
	to the target, and if it succeeds reaches through the connection to the
	client.
</p>
<pre class="http">
Client: Please let me connect to IP 1.2.3.4.
Proxy:  Trying to connect... please hold the line ...
Proxy:  Here's the connection handle, any further data will be dispatched through automatically.
</pre>
<pre class="http">
Client: Please let me connect to IP 1.2.3.4.
Proxy:  Trying to connect... please hold the line ...
Proxy:  Sorry, the given target is not reachable. Please try again later.
Proxy:  *hangs off the phone* Beep Beep Beep.
</pre>
<p>
	As both 
	 <code>SOCKS4</code>
	 and 
	 <code>SOCKS4a</code>
	 were proprietary protocols, they didn't
	have any RFC. 
	 <code>SOCKS5</code>
	 is referring a lot the 
	 <code>SOCKS4</code>
	 protocol and
	its featureset, so reading the RFC is quite complicated if you don't
	know what the older protocol versions actually did feature-wise.
</p>
<p>
	Usually though, most clients and servers that claim to support SOCKS5
	actually only support the 
	 <code>user</code>
	 and 
	 <code>password</code>
	 authentication, not
	the 
	 <code>IPv6</code>
	 or 
	 <code>DNS/UDP</code>
	 related features that come with it.
</p>
<p>
	This implementation will focus mostly on the 
	 <code>IPv4</code>
	 and 
	 <code>IPv6</code>
	differences and will - for the sake of simplicity - only support 
	 <code>TCP</code>
	based connections.
</p>
<p>
	The 
	 <code>SOCKS4</code>
	 featureset
	:
</p>
<ul>
	<li>connects to <code>IPv4</code> (TCP)</li>
</ul>
<p>
	The 
	 <code>SOCKS4a</code>
	 featureset
	:
</p>
<ul>
	<li>connects to <code>IPv4</code> (TCP)</li>
	<li>connects to <code>domain</code> (TCP)</li>
	<li>authentication via <code>user</code> is broken in practice (no password)</li>
</ul>
<p>
	The 
	 <code>SOCKS5</code>
	 featureset
	:
</p>
<ul>
	<li>connects to <code>IPv4</code> (TCP and UDP)</li>
	<li>connects to <code>IPv6</code> (TCP and UDP)</li>
	<li>connects to <code>domain</code> (TCP)</li>
	<li>authentication via <code>user</code> and <code>password</code></li>
</ul>
</section>

<section>
<h2>SOCKS Protocol and Network States</h2>
<p>
	Describing SOCKS data frames can be kind of complicated, because the
	interpretation of a SOCKS frame is different depending on its network
	state. So I'm trying to document the different network states first,
	so that you know what kind of states on both sides are possible.
</p>
<p>
	We are also going to completely ignore the 
	 <code>SOCKS authentication methods</code>
	,
	because they are broken across every single Browser; and implemented
	in specification violating non-secure non-encrypted manners across
	every piece of source code I've come across.
</p>
</section>

<section>
<h3>SOCKS Version 4</h3>
<p>
	The SOCKS 
	 <b>Version 4</b>
	 network flow looks like this
	:
</p>
<ul>
	<li>Client sends Connection Request Frame</li>
	<li>Server responds with a Status Frame</li>
</ul>
<p>... and that's pretty much it. Super simple.</p>
<p>
	 <b>SOCKS Version 4 Connection Request Frame</b>
	:
</p>
<pre class="bash">
+---------+---------+----+----+----+----+----+----+----+----+....+----+
| VERSION | COMMAND | DSTPORT |      DSTIP        | USERID       |NULL|
+---------+---------+----+----+----+----+----+----+----+----+....+----+
     1         1         2              4           variable       1
</pre>
<ul>
	<li><code>VERSION</code> (1 byte) represents the <code>SOCKS version</code> , which can be either of <code>0x04</code> or <code>0x05</code> .</li>
	<li><code>COMMAND</code> (1 byte) represents the <code>SOCKS command</code> , which can be either of the Commands explained below.</li>
	<li><code>DSTPORT</code> (2 bytes) represents the destination port from <code>1</code> to <code>65535</code> .</li>
	<li><code>DSTIP</code> is an <code>IPv4</code> (4 bytes) represents the destination IP, and encodes 4 digits as <code>0x00</code> to <code>0xFF</code> respectively.</li>
	<li><code>USERID</code> (variable byte length, followed by a <code>NULL</code> terminator byte) represents an authentication mechanism for a user-login; but without a password.</li>
</ul>
<p>
	 <b>SOCKS Version 4 Commands</b>
	:
</p>
<ul>
	<li><code>0x01</code> represents <code>CONNECT</code> and is a TCP/IP connection request which lets the Server established the connection.</li>
	<li><code>0x02</code> represents <code>BIND</code> and is a TCP/IP port binding to allow the Client to establish the connection themselves.</li>
</ul>
<p>
	 <b>SOCKS Version 4 Connection Status Frame</b>
	:
</p>
<pre class="bash">
+---------+--------+----+----+----+----+----+----+
| VERSION | STATUS | DSTPORT |      DSTIP        |
+---------+--------+----+----+----+----+----+----+
     1         1        2              4
</pre>
<ul>
	<li><code>VERSION</code> (1 byte) represents the <code>SOCKS version</code> , which can be either of <code>0x04</code> or <code>0x05</code> .</li>
	<li><code>STATUS</code> (1 byte) represents the <code>SOCKS status</code> , which can be either of the Status explained below.</li>
	<li><code>DSTPORT</code> (2 bytes) represents the destination port from <code>1</code> to <code>65535</code> .</li>
	<li><code>DSTIP</code> is an <code>IPv4</code> (4 bytes) represents the destination IP, and encodes 4 digits as <code>0x00</code> to <code>0xFF</code> respectively.</li>
</ul>
<p>
	 <b>SOCKS Version 4 Status Codes</b>
	:
</p>
<ul>
	<li><code>0x5A</code> Request granted.</li>
	<li><code>0x5B</code> Request rejected or failed.</li>
</ul>
<p>
	 <b>SOCKS Version 4 Status Codes for Authentication Mechanism</b>
	:
</p>
<p>(I would not recommend to implement them)</p>
<ul>
	<li><code>0x5C</code> Request failed because Client's <code>identd</code> is not reachable from server.</li>
	<li><code>0x5D</code> Request failed because Client's <code>identd</code> could not confirm the User ID.</li>
</ul>
</section>

<section>
<h3>SOCKS Version 5</h3>
<p>
	 <b>Important</b>
	:
	 The SOCKS Version 5 protocol is different in
	its network flow and data frame structure; and it has a
	reserved byte with a 
	 <code>0x00</code>
	 value where the SOCKS Version 4
	protocol would otherwise expect a non-NULL byte data.
</p>
<p>
	Additionally, the order of 
	 <code>Destination Port</code>
	 and 
	 <code>Destination Address</code>
	is different from the order specified in SOCKS Version 4.
</p>
<p>
	The SOCKS 
	 <b>Version 5</b>
	 network flow looks like this
	:
</p>
<ol>
	<li>Client and Server authenticate via handshake mechanism.</li>
	<li>Server authenticates or responds with error message.</li>
	<li>Client requests to connect or bind to an IPv4, IPv6 or domain.</li>
	<li>Server responds with connection status.</li>
</ol>
<p>
	 <b>SOCKS Version 5 Handshake Request Frame</b>
	:
</p>
<pre class="bash">
+---------+----+----+----+....+
| VERSION | NMETHODS| METHODS |
+---------+----+----+----+....+
     1         2      variable
</pre>
<p>
	 <b>SOCKS Version 5 Handshake Response Frame</b>
	:
</p>
<pre class="bash">
+---------+----+----+
| VERSION | METHOD  |
+---------+----+----+
     1         1
</pre>
<ul>
	<li><code>VERSION</code> (1 byte) represents the <code>SOCKS version</code> , which is <code>0x05</code> .</li>
	<li><code>NMETHODS</code> (1 byte) represents the byte length of the following encoded <code>METHOD</code> s.</li>
	<li><code>METHODS</code> (variable byte length) represents the encoded SOCKS methods.</li>
</ul>
<p>
	 <b>SOCKS Version 5 Handshake Methods</b>
	:
</p>
<ul>
	<li><code>0x00</code> represents No Authentication required.</li>
	<li><code>0x01</code> represents <code>GSSAPI</code> which is a "secure" context as defined per <a class="icon-website" href="https://tools.ietf.org/html/rfc1961">RFC1961</a> .</li>
	<li><code>0x02</code> represents <code>username/password</code> plaintext authentication.</li>
	<li><code>0x80</code> to <code>0xFE</code> are reserved for private methods, but are never used in practice.</li>
	<li><code>0xFF</code> represents No Acceptable methods (in a response).</li>
</ul>
<p>
	 <b>SOCKS Version 5 Connection Request</b>
	:
</p>
<p>
	After the Client and Server have negotiated an Authentication Method,
	the Client sends a Connection Request Frame to the Server.
</p>
<pre class="bash">
+---------+---------+-----+------+----+----+----+----+
| VERSION | COMMAND | RSV | ATYP | DSTADDR | DSTPORT |
+---------+---------+-----+------+----+----+----+----+
     1         1       1      1    variable     2
</pre>
<ul>
	<li><code>VERSION</code> (1 byte) represents the <code>SOCKS version</code> , which is <code>0x05</code> .</li>
	<li><code>COMMAND</code> (1 byte) represents either of the Commands explained below.</li>
	<li><code>RSV</code> (1 byte) represents the reserved byte which has to be <code>0x00</code> (to be able to differ it from a SOCKS Version 4 Connection Request).</li>
	<li><code>ATYP</code> (1 byte) represents the address type, which can be either of <code>0x01</code> (IPv4 address), <code>0x03</code> (domain name), <code>0x04</code> (IPv6 address).</li>
	<li><code>DSTADDR</code> (variable) represents the destination address as an IPv4 (in 4 octets), the domain name (with a prefixed byte length), or an IPv6 (in 16 octets).</li>
	<li><code>DSTPORT</code> (2 bytes) represents the destination port from <code>0x01</code> ( <code>1</code> ) to <code>0xFF</code> ( <code>65535</code> ).</li>
</ul>
<p>
	 <b>SOCKS Version 5 Commands</b>
	:
</p>
<ul>
	<li><code>0x01</code> represents <code>CONNECT</code> and is a TCP/IP connection request which lets the Server established the connection and forward further packets.</li>
	<li><code>0x02</code> represents <code>BIND</code> and is a TCP/IP port binding to allow the Client to establish the connection themselves.</li>
	<li><code>0x03</code> represents <code>UDP ASSOCIATE</code> and is a UDP associate request which lets the Server establish the connection and forward further packets.</li>
</ul>
<p>
	 <b>SOCKS Version 5 Connection Status Frame</b>
	:
</p>
<p>
	After the Client has sent the Connection Request frame, the Server responds
	with a Connection Status Frame.
</p>
<pre class="bash">
+---------+-------+-----+------+----+----+----+----+
| VERSION | REPLY | RSV | ATYP | BNDADDR | BNDPORT |
+---------+-------+-----+------+----+----+----+----+
     1        1      1      1    variable     2
</pre>
<ul>
	<li><code>VERSION</code> (1 byte) represents the <code>SOCKS version</code> , which is <code>0x05</code> .</li>
	<li><code>REPLY</code> (1 byte) represents the reply message to the requested command and is either of the Replies explained below.</li>
	<li><code>RSV</code> (1 byte) represents the reserved byte which has to be <code>0x00</code> (to be able to differ it from a SOCKS Version 4 Connection Request).</li>
	<li><code>ATYP</code> (1 byte) represents the address type, which can be either of <code>0x01</code> (IPv4 address), <code>0x03</code> (domain name), <code>0x04</code> (IPv6 address).</li>
	<li><code>BNDADDR</code> (variable) represents the server-bound destination address as an IPv4 (in 4 octets), the domain name (with a prefixed byte length), or an IPv6 (in 16 octets).</li>
	<li><code>BNDPORT</code> (2 bytes) represents the server-bound destination port from <code>0x01</code> ( <code>1</code> ) to <code>0xFF</code> ( <code>65535</code> ).</li>
</ul>
<p>
	 <b>SOCKS Version 5 Replies</b>
	:
</p>
<ul>
	<li><code>0x00</code> Success</li>
	<li><code>0x01</code> General SOCKS Failure</li>
	<li><code>0x02</code> Connection Not Allowed</li>
	<li><code>0x03</code> Network Unreachable</li>
	<li><code>0x04</code> Host Unreachable</li>
	<li><code>0x05</code> Connection Refused</li>
	<li><code>0x06</code> TTL (Time To Live) Expired</li>
	<li><code>0x07</code> Command Not Supported</li>
	<li><code>0x08</code> Address Type Not Supported</li>
</ul>
</section>

<section>
<h2>SOCKS Client</h2>
<p>The demo will be implemented using modern node.js.</p>
<p>
	The client has to be implemented with the 
	 <code>net.createConnection()</code>
	interface, as the data that we need to access is 
	 <code>raw TCP data</code>
	and our library needs to support binary encodings.
</p>
<p>
	As node.js runs 
	 <code>libuv</code>
	 in the background, which is of asynchronous
	nature, we also have to make sure that everything gets send as soon
	as possible by calling 
	 <code>socket.setNoDelay(true)</code>
	.
</p>
<pre class="javascript">
// client.mjs
import net       from 'net';
import { SOCKS } from './SOCKS.mjs';



// Chapter: SOCKS Client
let client = new net.createConnection({
	host: 'localhost',
	port: 1080
}, () => {

	let handshake = {
		headers: {
			'auth': [ 'none' ]
		}
	};

	// Chapter: Handshake Request
	console.log('Send Handshake Request', handshake);
	SOCKS.send(client, handshake);

});

client.once('data', (response) => {

	client.allowHalfOpen = false;
	client.setTimeout(0);
	client.setNoDelay(true);
	client.setKeepAlive(true, 0);

	client.removeAllListeners('timeout');
	client.removeAllListeners('data');

	// Chapter: Handshake Response
	SOCKS.receive(client, response, (data) => {

		console.log('Receive Handshake Response', data);

		if (data.headers['@version'] === 0x05 && data.headers['auth'] === 'none') {

			// Chapter: Connection Status
			client.once('data', (status) => {

				SOCKS.receive(client, status, (data) => {

					console.log('Receive Connection Status', data);

					if (data.headers['@status'] === 'success') {
						console.log('Client would be ready to do a HTTP request to ' + data.payload.host + ':' + data.payload.port + ' now.');
						// TODO: client.write(HTTP_REQUEST);
						client.destroy();
					} else {
						console.error('Server responded with an Error: ' + data.headers['@status']);
						client.destroy();
					}

				});

			});

			setTimeout(() => {

				let request = {
					headers: {
						'@method': 'connect'
					},
					payload: {
						domain: 'cookie.engineer',
						port:   80 // HTTP
					}
				};

				// Chapter: Connection Request
				console.log('Send Connection Request', request);
				SOCKS.send(client, request);

			}, 1000);

		} else {
			client.destroy();
		}

	});

	SOCKS.receive(response);

});

client.on('error',   () => {});
client.on('close',   () => {});
client.on('timeout', () => client.destroy());
</pre>
</section>

<section>
<h2>Handshake Request and Response</h2>
<p>
	The initial Handshake Request that is done from the Client in order to
	find out what kinds of 
	 <code>auth</code>
	 methods the Server supports.
</p>
<p>
	In the following example, we'll emulate a simple SOCKS Version 5 Client
	to explain the previous example of the Client in more detail
	:
</p>
<pre class="javascript">
// client-manual.mjs
import net from 'net';



const HANDSHAKE_REQUEST = [
	0x05, // SOCKS version
	0x02, // 2 Auth Methods are supported
	0x00, // methods[0]: No Authentication Required
	0x02  // methods[1]: Username/Password
];


net.connect({
	host: '127.0.0.1',
	port: 1080
}, () => {

	socket.once('data', (response) => {

		console.log('Handshake Response Frame', response);
		console.log('Server\'s SOCKS version (should be 0x05):', response[0]);
		console.log('Server\'s selected Auth Method (should be 0x00):', response[1]);

		// Chapter: Connection Request

	});

	socket.write(HANDSHAKE_REQUEST);

});
</pre>
</section>

<section>
<h2>Connection Request and Status</h2>
<p>
	A SOCKS Server should be able to handle both 
	 <code>connect</code>
	 and 
	 <code>bind</code>
	 requests
	for 
	 <code>IPv4</code>
	 addresses, requested 
	 <code>domain</code>
	s, and 
	 <code>IPv6</code>
	 addresses.
</p>
<p>
	The Connection Request is sent by the Client after the Authentication Method
	was completed, which means that for _all_ Connection Requests there is an
	Handshake Request and Response Frame that preceeds it; as there are no
	reusable Sessions in SOCKS and sockets cannot be reused.
</p>
<pre class="javascript">
// client-manual.mjs
import net from 'net';



const HANDSHAKE_REQUEST = [
	0x05, // SOCKS version
	0x02, // 2 Auth Methods are supported
	0x00, // methods[0]: No Authentication Required
	0x02  // methods[1]: Username/Password
];

const CONNECTION_REQUEST = [

	0x05, // SOCKS version
	0x01, // CONNECT Command
	0x00, // Reserved (due to SOCKS4 compatibility)
	0x01, // IPv4 Address Type

	0x01, // 1.3.3.7
	0x03,
	0x03,
	0x07,

	80    // HTTP

];


let client = net.createConnection({
	host: '127.0.0.1',
	port: 1080
}, () => {

	client.once('data', (response) => {

		console.log('Handshake Response Frame', response);

		if (response[0] === 0x05 && response[1] === 0x00) {

			client.once('data', (status) => {
				console.log('Connection Status Frame', status);
			});

			client.write(CONNECTION_REQUEST);

		}

	});

	client.write(HANDSHAKE_REQUEST);

});
</pre>
</section>

<section>
<h2>Receiving SOCKS Frames</h2>
<p>The integration of a receiving method for our SOCKS library is quite easy.</p>
<pre class="javascript">
// SOCKS.mjs
SOCKS.receive = (socket, buffer, callback) => {

	buffer   = buffer instanceof Buffer     ? buffer   : null;
	callback = callback instanceof Function ? callback : null;

	if (buffer !== null) {

		let data = decode(socket, buffer);
		if (data !== null) {

			if (callback !== null) {
				callback(data);
			}

			return data;

		}

	} else {

		if (callback !== null) {
			callback(null);
		} else {
			return null;
		}

	}

};
</pre>
</section>

<section>
<h3>Decoding Logic</h3>
<p>
	The Decoding Logic is a bit more complex, as it has to respect the following states
	:
</p>
<ul>
	<li>Server : If <code>buffer.length</code> is greater than <code>3</code> , it is a <code>connect</code> or <code>bind</code> Connection Request.</li>
	<li>Server : If <code>buffer.length</code> is <code>3</code> , it is a Handshake Request with a single Authentication Method (which is what all Web Browsers use).</li>
	<li>Server : Unsupported : If a Client sends more than a single authentication method, we won't support it.</li>
	<li>Client : If <code>buffer.length</code> is <code>2</code> , it is a Handshake Response.</li>
	<li>Client : If <code>buffer.length</code> is greater than <code>2</code> , it is a Connection Status Response.</li>
</ul>
<pre class="javascript">
// Chapter: Decoding Logic
const decode = function(socket, buffer) {

	let chunk = {
		headers: {},
		payload: null
	};

	if (buffer[0] === 0x05) {
		chunk.headers['@version'] = 5;
	} else if (buffer[0] === 0x04) {
		chunk.headers['@version'] = 4;
	}

	let is_server = socket._is_server === true;
	if (is_server === true) {

		// TODO: Support multiple Authentication Methods (buffer.length >= 3)
		if (buffer.length === 3) {

			let length  = buffer[1];
			let methods = buffer.slice(2, 2 + length);

			if (methods.length === length) {

				chunk.headers['auth'] = Array.from(methods).map((v) => {

					if (v === 0x00) {
						return 'none';
					} else if (v === 0x02) {
						return 'login';
					} else if (v === 0xff) {
						return 'error';
					}

					return null;

				}).filter((method) => method !== null);

			}

		} else if (buffer.length > 3) {

			let method = buffer[1];
			if (method === 0x01) {
				chunk.headers['@method'] = 'connect';
			} else if (method === 0x02) {
				chunk.headers['@method'] = 'bind';
			}

			let payload = decode_payload(buffer.slice(3));
			if (payload !== null) {
				chunk.payload = payload;
			}

		}

	} else {

		if (buffer.length === 2) {

			let auth = buffer[1];
			if (auth === 0x00) {
				chunk.headers['auth'] = 'none';
			} else if (auth === 0x02) {
				chunk.headers['auth'] = 'login';
			} else if (auth === 0xff) {
				chunk.headers['auth'] = 'error';
			}

		} else if (buffer.length > 2) {

			let reply = buffer[1];
			if (reply === 0x00) {
				chunk.headers['@status'] = 'success';
			} else if (reply === 0x01) {
				chunk.headers['@status'] = 'error';
			} else if (reply === 0x02) {
				chunk.headers['@status'] = 'error-blocked';
			} else if (reply === 0x03) {
				chunk.headers['@status'] = 'error-network';
			} else if (reply === 0x04) {
				chunk.headers['@status'] = 'error-host';
			} else if (reply === 0x05) {
				chunk.headers['@status'] = 'error-connection';
			} else if (reply === 0x07) {
				chunk.headers['@status'] = 'error-method';
			}

			if (buffer.length > 3) {

				let payload = decode_payload(buffer.slice(3));
				if (payload !== null) {
					chunk.payload = payload;
				}

			}

		}

	}

	return chunk;

};

const decode_payload = function(buffer) {

	let payload = null;

	let type = buffer[0];
	if (type === 0x01) {

		// Chapter: IPv4 Payload
		// 0x01: IPv4 Payload

	} else if (type === 0x03) {

		// Chapter: Domain Payload
		// 0x03: Domain Payload

	} else if (type === 0x04) {

		// Chapter: IPv6 Payload
		// 0x04: IPv4 Payload

	}

	return payload;

};
</pre>
</section>

<section>
<h3>0x01 : IPv4 Payload</h3>
<p>
	The 
	 <code>IPv4 Payload</code>
	 is sent to communicate that the Client wants to
	 <code>connect</code>
	 or 
	 <code>bind</code>
	 to a specific IP and a specific Port.
</p>
<p>
	The encoded format of an IPv4 Payload is
	:
</p>
<ul>
	<li><code>4 bytes</code> for the IP.</li>
	<li><code>2 bytes</code> for the Port.</li>
</ul>
<pre class="javascript">
// SOCKS.mjs in decode_payload()

if (type === 0x01) {

	// 0x01: IPv4 Payload

	let raw_host = buffer.slice(1, 5);
	let raw_port = buffer.slice(5, 7);

	if (raw_host.length === 4 && raw_port.length === 2) {

		let ip = [
			raw_host[0],
			raw_host[1],
			raw_host[2],
			raw_host[3]
		].join('.');
		let port = (raw_port[0] << 8) + (raw_port[1] & 0xff);

		if (port > 0 && port < 65535) {
			payload = ip + ':' + port;
		}

	}

}
</pre>
</section>

<section>
<h3>0x03 : Domain Payload</h3>
<p>
	The 
	 <code>Domain Payload</code>
	 is sent to communicate that the Client wants to
	 <code>connect</code>
	 or 
	 <code>bind</code>
	 to a specific domain (that the Server or Proxy
	has to resolve first) and a specific Port.
</p>
<p>
	In this case, the Server has to respond with a valid IP. If the IP
	response is 
	 <code>0.0.0.0</code>
	, the Client must handle this as an unsuccessful
	Connection Request.
</p>
<p>
	The encoded format of a Domain Payload is
	:
</p>
<ul>
	<li><code>1 byte</code> for the length of the Domain.</li>
	<li><code>n bytes</code> for the Domain, encoded as a <code>utf8</code> string.</li>
	<li><code>2 bytes</code> for the Port.</li>
</ul>
<pre class="javascript">
// SOCKS.mjs in decode_payload()

if (type === 0x03) {

	// 0x03: Domain Payload

	let length     = buffer[1];
	let raw_domain = buffer.slice(2, 2 + length);
	let raw_port   = buffer.slice(2 + length, 2 + length + 2);

	if (raw_domain.length > 0 && raw_port.length === 2) {

		let domain = Buffer.from(raw_domain).toString('utf8');
		let port   = (raw_port[0] << 8) + (raw_port[1] & 0xff);
		if (domain.length > 0 && port > 0 && port < 65535) {
			payload = domain + ':' + port;
		}

	}

}
</pre>
</section>

<section>
<h3>0x04 : IPv6 Payload</h3>
<p>
	The 
	 <code>IPv6 Payload</code>
	 is sent to communicate that the Client wants to
	 <code>connect</code>
	 or 
	 <code>bind</code>
	 to a specific IP and a specific Port.
</p>
<p>
	The encoded format of an IPv6 Payload is
	:
</p>
<ul>
	<li><code>8 bytes</code> for the IP.</li>
	<li><code>2 bytes</code> for the Port.</li>
</ul>
<pre class="javascript">
// SOCKS.mjs in decode_payload()

if (type === 0x04) {

	let raw_host = buffer.slice(1, 17);
	let raw_port = buffer.slice(17, 19);

	if (raw_host.length === 16 && raw_port.length === 2) {

		let ip = [
			raw_host.slice( 0,  2).toString('hex'),
			raw_host.slice( 2,  4).toString('hex'),
			raw_host.slice( 4,  6).toString('hex'),
			raw_host.slice( 6,  8).toString('hex'),
			raw_host.slice( 8, 10).toString('hex'),
			raw_host.slice(10, 12).toString('hex'),
			raw_host.slice(12, 14).toString('hex'),
			raw_host.slice(14, 16).toString('hex')
		].join(':');
		let port = (raw_port[0] << 8) + (raw_port[1] & 0xff);

		if (port > 0 && port < 65535) {
			payload = '[' + ip + ']:' + port;
		}

	}

}
</pre>
</section>

<section>
<h2>Sending SOCKS Frames</h2>
<p>The integration of a sending method for our SOCKS library is quite easy.</p>
<pre class="javascript">
// SOCKS.mjs
SOCKS.send = (socket, data) => {

	data = data instanceof Object ? data : { headers: {}, payload: null };


	let buffer = encode(socket, data);
	if (buffer !== null) {
		socket.write(buffer);
	}

};
</pre>
</section>

<section>
<h3>Encoding Logic</h3>
<p>
	The Encoding Logic is a bit more complex, as it has to respect the following states
	:
</p>
<ul>
	<li>Server : If <code>headers['@version']</code> is set to <code>0x05</code> or <code>0x04</code> , set the SOCKS protocol version.</li>
	<li>Server : If <code>headers['auth']</code> is either <code>none</code> or <code>login</code> , transmit a Handshake Response Frame.</li>
	<li>Server : If <code>headers['@status']</code> is set, transmit a Connection Status Frame.</li>
	<li>Client : If <code>headers['auth']</code> is an <code>Array</code> , transmit a Handshake Request Frame.</li>
	<li>Client : If <code>headers['@method']</code> is set, transmit a Connection Request Frame.</li>
</ul>
<pre class="javascript">
// Chapter: Encoding Logic
const encode = function(socket, data) {

	data = data instanceof Object ? data : { headers: {}, payload: null };


	if ((data.headers instanceof Object) === false) {
		data.headers = {};
	}


	let blob = [ 0x05 ];

	if (data.headers['@version'] === 5) {
		blob[0] = 0x05;
	} else if (data.headers['@version'] === 4) {
		blob[0] = 0x04;
	}

	let is_server = socket._is_server === true;
	if (is_server === true) {

		if (typeof data.headers['auth'] === 'string') {

			if (data.headers['auth'] === 'none') {
				blob[1] = 0x00;
			} else if (data.headers['auth'] === 'login') {
				blob[1] = 0x02;
			} else {
				blob[1] = 0xff;
			}

		} else if (typeof data.headers['@status'] === 'string') {

			if (data.headers['@status'] === 'success') {
				blob[1] = 0x00;
			} else if (data.headers['@status'] === 'error-blocked') {
				blob[1] = 0x02;
			} else if (data.headers['@status'] === 'error-network') {
				blob[1] = 0x03;
			} else if (data.headers['@status'] === 'error-host') {
				blob[1] = 0x04;
			} else if (data.headers['@status'] === 'error-connection') {
				blob[1] = 0x05;
			} else if (data.headers['@status'] === 'error-method') {
				blob[1] = 0x07;
			} else if (data.headers['@status'] === 'error') {
				blob[1] = 0x01;
			}

			blob[2] = 0x00;

			let payload = encode_payload(data.payload);
			if (payload !== null) {
				payload.forEach((v) => {
					blob.push(v);
				});
			}

		}

	} else {

		if ((data.headers['auth'] instanceof Array) === true) {

			let methods = data.headers['auth'].map((v) => {

				if (v === 'none') {
					return 0x00;
				} else if (v === 'login') {
					return 0x02;
				}

				return null;

			}).filter((method) => method !== null);
			let length = methods.length;

			blob[1] = length;
			methods.forEach((v) => {
				blob.push(v);
			});

		} else if (data.headers['@method'] === 'connect') {

			blob[1] = 0x01;
			blob[2] = 0x00;

			let payload = encode_payload(data.payload);
			if (payload !== null) {
				payload.forEach((v) => {
					blob.push(v);
				});
			}

		}

	}


	if (blob.length > 1) {
		return Buffer.from(blob);
	}


	return null;

};
</pre>
</section>

<section>
<h3>0x01 : IPv4 Payload, 0x03 : Domain Payload, 0x04 : IPv6 Payload</h3>
<p>
	The decoding logic has been explained already in the previous chapters,
	so it should be quite easy for you to handle the encoding of the payloads
	and possible to write the 
	 <code>encode_payload</code>
	 method yourself.
</p>
<p>
	The method should handle two different scenarios
	:
</p>
<ul>
	<li>Encode a <code>{host,port}</code> Payload Object.</li>
	<li>Encode a <code>{domain,port}</code> Payload Object.</li>
</ul>
<p>
	In any Error Case, a Payload representing the IPv4 
	 <code>0.0.0.0</code>
	 and the Port
	 <code>0</code>
	 should be returned.
</p>
</section>

<section>
<h2>SOCKS Server</h2>
<p>
	The SOCKS Server is responsible for a lot of things, as it has
	to handle the Handshake Requests and the Connection Requests
	without a Session.
</p>
<p>
	This means that for the Server has support the following states
	:
</p>
<ul>
	<li>Handshake Request with the <code>none</code> Authentication Method.</li>
	<li>Connection Request for the <code>IPv4</code> Payload.</li>
	<li>Connection Request for the <code>Domain</code> Payload.</li>
	<li>Connection Request for the <code>IPv6</code> Payload.</li>
	<li>The Connection Request's <code>connect</code> Method.</li>
	<li>Unsupported : Handshake Request with the <code>auth</code> Authentication Method is currently unsupported (as it's unsecure as already explained).</li>
	<li>Unsupported : The Connection Request's <code>bind</code> Method. It seems to be not used in the wild by any Web Browser anyways.</li>
</ul>
<pre class="javascript">
// server.mjs

import dns from 'dns';
import net from 'net';

import { SOCKS } from './SOCKS.mjs';



// Chapter: SOCKS Server
let server = new net.Server({
	allowHalfOpen:  true,
	pauseOnConnect: true
});

server.on('connection', (socket) => {

	socket._is_server = true;

	socket.allowHalfOpen = true;
	socket.setNoDelay(true);
	socket.setKeepAlive(true, 0);


	socket.once('data', (request) => {

		if (request[0] === 0x05) {

			SOCKS.receive(socket, request, (data) => {

				console.log('Receive Handshake Request', data);

				if (
					data.headers['@version'] === 5
					&& data.headers['auth'].includes('none')
				) {

					socket.removeAllListeners('data');


					socket.once('data', (request) => {

						SOCKS.receive(socket, request, (data) => {

							console.log('Receive Connection Request', data);

							// Chapter: Connection Status
							if (
								data.headers['@version'] === 5
								&& data.headers['@method'] === 'connect'
							) {

								// Chapter: Handling Host Connections
								// Chapter: Handling Domain Connections

							} else {
								socket.end();
							}

						});

					});


					setTimeout(() => {

						SOCKS.send(socket, {
							headers: {
								'@version': 5,
								'auth':     'none'
							},
							payload: null
						});

					}, 0);

				} else {
					socket.end();
				}

			});

		} else {
			socket.end();
		}

	});

	socket.resume();

});

server.on('error', () => server.close());
server.on('close', () => (server = null));

server.listen(1080, null);
</pre>
</section>

<section>
<h2>Connection Status</h2>
<p>
	The Connection Status Frame is sent by the SOCKS Server to the Client after the Server
	connected to (or tried to connect to) the requested Host or Domain.
</p>
</section>

<section>
<h2>Handling Host Connections</h2>
<p>
	A Connection Request for a Host is quite easy to create, as it requires only a simple
	TCP-based Network Tunnel. The Server creates a TCP Socket to the Target Host and
	dispatches it through to the Client. Further Data sent by the Client will then just
	be delegated to the Target Host.
</p>
<pre class="javascript">
// server.mjs
// (somewhere down the network event flow)

// (...)
console.log('Receive Connection Request', data);

// Chapter: Connection Status
if (
	data.headers['@version'] === 5
	&& data.headers['@method'] === 'connect'
) {

	let host   = data.payload.host   || null;
	let domain = data.payload.domain || null;
	let port   = data.payload.port   || null;

	if (host !== null && port !== null) {

		let tunnel = null;

		try {
			tunnel = net.connect({
				host: host,
				port: port
			}, () => {

				socket.pipe(tunnel);
				tunnel.pipe(socket);

				let status = {
					headers: {
						'@version': 5,
						'@status':  'success'
					},
					payload: {
						host: host,
						port: port
					}
				};

				console.log('Send Connection Status', status);
				SOCKS.send(socket, status);

			});
		} catch (err) {
			tunnel = null;
		}

		if (tunnel === null) {
			SOCKS.send(socket, {
				headers: {
					'@version': 5,
					'@status':  'error-network'
				},
				payload: null
			});
		}

	} else if (domain !== null && port !== null) {

		// Chapter: Handling Domain Connections

	} else {
		// (...)
	}
}
</pre>
</section>

<section>
<h2>Handling Domain Connections</h2>
<p>
	A Connection Request for a Domain requires a 
	 <code>dns.resolve4()</code>
	 or 
	 <code>dns.resolve6()</code>
	 call
	before, and on successfully resolved 
	 <code>A</code>
	 or 
	 <code>AAAA</code>
	 domain entries a connection to those
	addresses.
</p>
<p>
	In theory, failed connections to the specific addresses should gracefully try out all
	other entries if there are multiple available; but in practice no SOCKS Proxy supports
	that. I'll leave that up to the reader to implement it, as it requires a timeout loop
	that gradually checks for network timeouts and failure scenarios of the 
	 <code>net.connect()</code>
	API in node.js, which is rather unclean to implement for demo purposes.
</p>
<p>
	Afterwards, the same Network Flow happens as in the Handling Host Connections example,
	where the Tunnel is piped through to the Client and further Data received is delegated
	to the Target Host.
</p>
<pre class="javascript">
// server.mjs
// (somewhere down the network event flow)

// (...)
console.log('Receive Connection Request', data);

// Chapter: Connection Status
if (
	data.headers['@version'] === 5
	&& data.headers['@method'] === 'connect'
) {

	let host   = data.payload.host   || null;
	let domain = data.payload.domain || null;
	let port   = data.payload.port   || null;

	if (host !== null && port !== null) {

		// Chapter: Handling Host Connections

	} else if (domain !== null && port !== null) {

		// TODO: Integrate IPv6 support
		dns.resolve4(domain, (err, addresses) => {

			if (err === null) {

				// TODO: Integrate timeout loop for addresses
				if (addresses.length > 0) {

					let tunnel = null;

					try {

						tunnel = net.connect({
							host: addresses[0],
							port: port
						}, () => {

							socket.pipe(tunnel);
							tunnel.pipe(socket);

							let status = {
								headers: {
									'@version': 5,
									'@status':  'success'
								},
								payload: {
									host: addresses[0],
									port: port
								}
							};

							console.log('Send Connection Status', status);
							SOCKS.send(socket, status);

						});

					} catch (err) {
						tunnel = null;
					}

					if (tunnel === null) {
						SOCKS.send(socket, {
							headers: {
								'@version': 5,
								'@status':  'error-network'
							},
							payload: null
						});
					}

				} else {
					SOCKS.send(socket, {
						headers: {
							'@version': 5,
							'@status':  'error-network'
						},
						payload: null
					});
				}

			} else {
				SOCKS.send(socket, {
					headers: {
						'@version': 5,
						'@status':  'error-network'
					},
					payload: null
				});
			}

		});

	} else {
		// (...)
	}

}
</pre>
</section>

<section>
<h2>Reference Implementation</h2>
<p>
	That's it. Our implementation is now fully peer-to-peer
	ready and supports the complete 
	 <code>SOCKS5</code>
	 protocol.
</p>
<p>
	In case you missed something in between the lines or
	made a mistake, there's a reference implementation
	available.
</p>
<ul>
	<li><a class="icon-download" href="/weblog/articles/implementers-guide-to-socks/client.mjs">client.mjs</a></li>
	<li><a class="icon-download" href="/weblog/articles/implementers-guide-to-socks/client-manual.mjs">client-manual.mjs</a></li>
	<li><a class="icon-download" href="/weblog/articles/implementers-guide-to-socks/server.mjs">server.mjs</a></li>
	<li><a class="icon-download" href="/weblog/articles/implementers-guide-to-socks/SOCKS.mjs">SOCKS.mjs</a></li>
</ul>
</section>
			</article>
		</section>
		<footer>
			<p class="print-not">Made with 💔 in Heidelberg, Germany. All rights (and jokes) reserved under European Law.</p>
			<p>&copy; Cookie Engineer (https://cookie.engineer). All rights reserved.</p>
		</footer>
	</body>
</html>
